export type Post={
    id:number,
    color:string,
    title:string,
    info:string,
    content:string
}

export const posts: Post[] = [
    {id:0,color:"#b6ba36",title:"Por que PhP é uma boa para iniciantes?",info:"12/06" ,content: "Com 3 argumentos eu vou mostrar o porque de php ser uma das melhores linguagens para iniciantes. <br> <br> <br> <strong>1 - Cliente - Servidor:</strong> <br> <br> O PHP ao mesmo tempo que separa bem o backend do frontend, também facilita entender as funções de cada um, forçando um entendimento mesmo que básico sobre servidores, já que é necessário um para rodar a linguagem, como o Apache. <br> <br> O PHP elimina a necessidade de API 's para fazer a comunicação, utilizando de formulários para se integrar ao frontend, que facilita um pouco para iniciantes, que mesmo escolhendo apenas uma área, vai ter uma noção básica de como funciona o outro lado. <br> <br> <br> <strong>2 - Arquitetura de software:</strong> <br>  <br> O Laravel (maior framework de PhP), introduz dois conceitos de forma simples, tanto de executar, quanto de entender: MVC e Migrations. <br> <br> O MVC no Laravel é quase que auto explicativo para qualquer iniciante, graças a relação entre front e backend citada no tópico anterior. Este modelo de arquitetura de software é bem versátil e pode ser utilizada nos mais diversos projetos e linguagens, introduzindo 3 conceitos: <br> <br> <strong>. Model -></strong> Onde o software faz a conexão com banco de dados, onde fica a lógica por trás do software e onde as regras de negócios são aplicadas, sendo o backend do software; <br> <br> <strong>. View -></strong> É onde fica localizado o frontend, as páginas que serão exibidas aos usuários;   <br> <br> <strong>. Controller  -> </strong>Faz a conexão entre o VIEW e o MODEL, atuando como um negociador intermediário e garantindo uma comunicação eficiente entre ambas as partes. <br> <br> Já as Migrations são uma excelente forma de manter o controle do banco de dados na hora de desenvolver, além de ser uma documentação para o mesmo, as Migrations permitem ter um controle de versões, podendo fazer e desfazer alterações no banco de dados de forma fácil. <br> <br> <br> <strong>3 - Frameworks:</strong> <br> <br> Como já citado no tópico anterior, o PHP conta com um dos melhores frameworks do mundo de desenvolvimento: o Laravel; que além do MVC, conta com um ótimo router e um ORM sensacional, facilitando o acesso ao banco de dados. <br> <br> Também existem outras excelentes opções, como o CakePHP, que tem uma curva de aprendizado suave e contém muitos recursos de forma nativa (como recursos de segurança), e o framework Symfony, com um alto desempenho, modular, estável e com várias ferramentas para auxiliar no desempenho, como o Symfony Console."},
    
    {id:1,color:"#228270",title:"Uma arquitetura simples",info:"16/07" ,content: "<h3>Já teve uma ideia e na hora de implementar ficou em duvida de qual arquitetura de software usar?</h3><br>A maioria das opções conhecidas parecem ser grandes e complexas demais para seu projeto simples. Você fica com dúvida se vale a pena ou não, e acaba com um código desorganizado, seja por ter usado uma arquitetura grande demais, ou por não ter usado nada, te deixando perdido na hora de modificar.<br><br><h4>Para estes casos, eu trago uma possível solução:</h4><br>Primeiro, é importante entender o <strong>conceito inicial</strong>. A arquitetura é pensada de forma <strong>modular</strong> e é separada em 2 grandes partes: o <strong>access</strong> e o <strong>auxiliar</strong>.<br><br>No <strong>access</strong>, é onde tudo que exporta do projeto deve ficar, como <strong>endpoints de api</strong>. É aqui que deve ser definida o que o projeto vai fornecer.<br><br>No <strong>auxiliar</strong>, é onde deve ficar todo o código que é responsável por fazer as <strong>tarefas definidas no access.</strong><br><br>Dentro de <strong>access</strong>, temos subpastas, como api, que armazena a lógica de endpoints, como um RestController do Spring<br><br>Dentro de <strong>auxiliar</strong>, temos subpastas, como: data, que armazena a lógica de comunicação com o banco de dados; processing, que armazena lógica de processamento de dados; types, que armazenam tipos próprios do projeto, e validation, que armazena lógica de validação.<br><br>Lembrando, que a arquitetura é pensada de forma <strong>modular</strong>, o importante aqui é entender o grau de separação da lógica de toda a aplicação. Tornando o projeto mais organizado.<br><br>Entendido o conceito, vamos agora pra uma <strong>demonstração.</strong> A linguagem usada na demonstração é Java.<br><br><hr><br> <span style='display: block; margin-left: 0px;'> <strong>access</strong></span> <span style='display: block; margin-left: 30px;'>api</span> <span style='display: block; margin-left: 0px;'><strong>auxiliar</strong></span> <span style='display: block; margin-left: 30px;'>processing</span> <span style='display: block; margin-left: 60px;'>MountPersonalJson.java</span> <span style='display: block; margin-left: 30px;'>data</span> <span style='display: block; margin-left: 60px;'>entities</span> <span style='display: block; margin-left: 60px;'>repositories</span> <span style='display: block; margin-left: 60px;'>services</span> <span style='display: block; margin-left: 30px;'>types</span> <span style='display: block; margin-left: 60px;'>enum_types</span> <span style='display: block; margin-left: 60px;'>dto</span> <span style='display: block; margin-left: 30px;'>validation</span> <span style='display: block; margin-left: 60px;'>NumberValidation.java</span><br><br><hr><br><br>Por fim, espero que tenha entendido a ideia por trás desta <strong>mini arquitetura</strong> e que possa fazer bom proveito dela nas <strong>suas</strong> aplicações."},
    
    {id:2,color:"#f57d9f",title:"Sempre escolha o simples",info:"02/08", content: "<h3>Pare de transformar um projeto simples em algo desnecessariamente complexo.</h3><br>Você criou um novo projeto. Um site simples, com opção de cadastro. Você decide implementar uma verificação de email ao criar conta, então você escreve toda a lógica necessária pra isto.<br><br>Um tempo depois, você, no auge do seu tédio, resolve como todo bom programador, criar um sistema de livraria. Você cria todo o backend, define o banco de dados, e na hora de implementar o client web pensa: 'Meu Deus! Vou ter que implementar a validação do email de novo'.<br><br>Você fica pensativo, e lembra de uma palavrinha mágica que ouviu falar em um post aleatório do LinkedIn: microservices.<br><br>Você pensa que encontrou a solução para evitar a reescrita, acha que a partir de agora, sua produtividade vai aumentar, seus códigos serão lindamente reutilizáveis.<br><br>Mas você é só um iniciante. Sofre pra implementar, não consegue lidar de forma satisfatória com autenticação, e agora tem mais um projeto pra hospedar (boa sorte se não tiver dinheiro).<br><br>Você agora se encontra triste, frustrado e desanimado.<br><br><h4>Mas há uma abordagem melhor e mais simples que pode evitar toda essa frustração.</h4><br>Biblioteca. Sim isso mesmo. Esta simples abordagem pode resolver seu problema de forma rápida e simples.<br><br>A moda da vez muitas vezes ofusca outras soluções. Criar uma lib é algo trivial em qualquer linguagem. Em python por exemplo, você até pode publicar facilmente no pypi.<br><br>Agora sim, você escreve sua lógica de verificar emails numa lib, e pode reutilizala em qualquer outro projeto, caso queira modificar algo, só precisa modificar em um só lugar, além de que não precisa de uma hospedagem própria ou validações / autenticações próprias de uma API.<br><br><h4>Após tudo isso...</h4><br>Após tudo isso, o que eu quero dizer é: <strong>Não é uma discussão entre Bibliotecas vs Microservices.</strong><br><br>O caso acima é só um exemplo pra chegar numa conclusão: <strong>SEMPRE ESCOLHA O SIMPLES</strong>. <br><br>A complexidade a mais só deve existir se for a ultima opção. Nunca parta da ideia de que você vai precisar de algo a mais e que o simples é pouco para o seu caso. Sempre busque em fóruns, reddit, pessoas com os mesmos problemas que o seu. Avalie a sua situação com cuidado, sempre vá escalando degrau por degrau, nunca tente começar já no topo da escada.<br><br>No fim das contas, é o simples que vai te trazer produtividade, que vai poupar seu dinheiro, que vai te dar menos dores de cabeça para desenvolver.<br><br>Sempre que pensar numa solução para um problema, repense com a seguinte pergunta em mente: ' <strong>Isto é realmente necessário?</strong> '."},

    {id:3,color:"#fff",title:"A linguagem do futuro",info:"00/00",content:"content"},

    {id:4,color:"#92df03",title:"Uma boa ideia de um simples Workflow",info:"06/08",content:"<h3>Vem comigo entender que nem sempre precisa ficar 100 horas personalizando o ambiente pra codar melhor.</h3><br>Nesse amigável artigo, usarei meu workflow como exemplo para que você tire insights para aproveitar no teu. <br><br><h4>Meu Workflow:</h4><br>Primeiro vou dizer minha stack e algumas ferramentas que uso: <br> <br> <span style='display: block; margin-left: 0px;'>> <strong>Frontend:</strong> TypeScript + Nuxt 3.</span> <span style='display: block; margin-left: 0px;'>> <strong>Backend:</strong> Java + Spring Boot.</span> <span style='display: block; margin-left: 0px;'>> <strong>Mobile:</strong> React Native.</span> <span style='display: block; margin-left: 0px;'>> <strong>Database:</strong> MySQL.</span> <span style='display: block; margin-left: 0px;'>> <strong>Cloud:</strong> Vercel.</span> <span style='display: block; margin-left: 0px;'>> <strong>CI/CD:</strong> GitHub Actions.</span> <span style='display: block; margin-left: 0px;'>> <strong>IDE:</strong> VsCode.</span><br><br> <h4>Configurando a IDE:</h4><br>Primeiro ponto: extensões. Instalei apenas as necessárias para rodar meus projetos, como o pacote de Java e o ESLint.<br><br>É comum cairmos em um loop de busca por extensões que supostamente vão transformar nossa produtividade. Assistimos a vídeos intermináveis listando extensões 'mágicas', quando na verdade, o mais eficiente é instalar apenas o essencial. À medida que a necessidade surgir, aí sim devemos buscar extensões para resolver problemas específicos na IDE.<br><br>Também aproveitei pra remover da tela alguns elementos que eu nunca uso, como a maioria dos menus visiveis do VsCode (status bar, activity bar, etc), melhorando no foco e deixando uma tela limpa para focar no código.<br><br><h4>Database:</h4><br>Na maioria dos casos, acabo usando o MySQL, por este motivo, não vejo necessidade de alguma coisa além do MySQL Workbench pra gerenciar meus bancos de dados.<br><br><h4>Mobile:</h4><br>Em 100% dos casos, uso o Expo junto ao React Native, testando o app no navegador, ou no meu celular com o app Expo Go. <br><br>Usar o Expo elimina a necessidade de usar um emulador como o PESADÍSSIMO Android Studio.<br><br><h4>Fluxo de trabalho:</h4><br>Agora, vou listar os passos que costumo seguir ao desenvolver: <br> <br> <span style='display: block; margin-left: 0px;'>> Abro o projeto no VsCode.</span> <span style='display: block; margin-left: 0px;'>> Inicio o Git.</span> <span style='display: block; margin-left: 0px;'>> Inicio o projeto configurando as dependências iniciais (como pom.xml ou package.json).</span> <span style='display: block; margin-left: 0px;'>> Configuro o GitHub Actions no processo de CI/CD integrado com a Vercel.</span> <span style='display: block; margin-left: 0px;'>> Crio o código necessário.</span> <span style='display: block; margin-left: 0px;'>> Crio os testes.</span> <span style='display: block; margin-left: 0px;'>> Ativo o trigger configurado no GitHub Actions, que vai fazer o deploy se tudo estiver minimamente correto.</span><br><br><h4>Extra:</h4><br>Além do que foi dito acima, tem mais uma coisa: atalhos no terminal.<br><br>Como eu uso linux, é ridiculamente fácil configurar atalhos, então eu costumo encurtar comandos, como o git push, git pull, npm run dev, etc. Com o tempo eu me acostumei com meus atalhos e agora digito um pouco menos.<br><br><h4>Conclusão:</h4><br>Existem diversas ferramentas que podem ser legais de integrar no seu workflow, como WakaTime, pra ter métricas de tempo codando e trabalhando em projetos. <br><br>Mas esse tipo de ferramenta eu considero como não essencial, que eu não dedicaria muito dos meus neurônios para utilizar e integrar, fazendo isso quando realmente não tem nada muito importante pra fazer."}
]